Introduction to DS and AI 
===========================
Data Heirarchy :-
1. Data Technology : Technology which drives under data./which is data driven
2. Data can be structured and Non Structured

Who is going to use Data 
1. Human : Data Science
2. Machine : AI  and (ML)

Human Driven:-
=============== 
SQL is mendatory -- Intermediate Level
Python+R+ Maths
----------Pre-requistic --------------------------
1. Data Analyst (Power BI)
2. Data Engineer (Power By and Pypark, ETL(Extract,Transform,Load) Pipelines)
3. Big Data Engineer (HADOOP,BHive,Apache Pig,scala and Haskel)
4. Data Warehouse Engineer (facts,marts,datalake,procedures,ETL Pipelines,Pyspark)
   (Move to AI/ML)
   
Machine Driven :-
===================
1. AI : Branch of CS which whose intent is to replicate,respond,mimic like human behaviour or 
Intelligence is called as AI.
	Intention : To make Intelligent System.
2. ML : sub set of AI in which machines learns from data(labelled,un-labelled data)
3. DL : Deep Learning : Design -> Artificial Neural Network
4. CV : Computer vision 
5. MLOPS : Machine Learning and Operations 

----------------------Bottom of AI-----------------------------
Generative Ai 
	1. DL 
	2. NLP 
	3. Tokenisation 
	4. Vectorisation 
	5. Tensorization 
	6  Cuda Core
	7. Embedding (Encoder/Decoder)
	8. vector Embedding
	9. Tensor Embedding
	10. Bidirectoral Vector Embedding
	11. grok infrastructure
	12. crew.ai infrastructure
	13. Transformers.
	14. Rag System
Agentic Ai (Langchain,Langraph,LammaIndex)
Adk (Agent Development Kit)

Cloud Infrastructure 
1. Azure Cloud 
2. AWS (Sagemaker and Bedrock)
3. GCP (Google Cloud Plateform) : VERTEX AI 

17-07-2025:-
==============
1. we worked with input()
	1. input() : No Output is scene in the console, 
		Problem with this input :-
		1. we need to add print()
		2. use will not be able to what to do.
		it is not recommended to be used. rather we must go for second case.
	2. input("Enter the value:")
	   steps 
	   1. Enter the value :20 
	   name = input('Enter the value:')
	   name => 20
	   return type : string 
	   
	   if you want perform some arthmetic operation, in this case you need to type cast.
	   
	   type casting in python :-
	   =======================
	   1. implicit typecasting : automatic type conversion.
	   2. explicit typecasting : user will forcefully change the datatype.
	   
	   maths :-
	   int + int = int 
	   int - int =  int 
	   int * int  = int 
	   int/int = 
			1. if type is strict => int 
			2. if type is flexible => float
			
Python :  similar datatype 
Mathematical : Type of left and type of right must be numeric (float,int,double)   
floor() => 2.2,2.3,2.9 => 2
ceil()	2.2,2.3,2.9 => 3
floor(2) 
ceil(2)
floor(2) == ceil(2) => valid 

Data Types:-
=============
1. primitive Data Types 
2. collection Data Types 

name mangling in Python:-
========================
in python naming convention plays a very important in terms of varible naming 
classname function naming, of any Indentifiers.

mangled name:  these are special indentifier which when named with this concept
	inherit special behaviour.
	mangled names called as magic names 
	1. magic varible
	2. magic function 
	3. magic module
	__init__
	__doc__
	
	if we utilise _ as prefix or suffix then behaviour becomes mangled.
	eg : _ it is a mangled keyword 
	 _  : softkeyword 
	 _ : Buffer Opererator : holds the last result.
	 _ : numeric sperator : used to improve readability of large numbers.
	 
	 These are actually reserved by the python but we can change the behaviour 
	 of these keyword 
	 _ and j 
	 j : complex imaginary we can change the behaviour
	 
	 _ can be used private,public and protected naming convention.
	 
	 
non mangled name : These are normal naming convention and in this we can use 
_ as part of snake case.

21-07-2025:-
===========
Operators :-
Operators are the special symbols which defines the relationship b/w two operands
which on evaluating gives desired result.

2 [+] 2 = 4
2 [*] 2 = 4
================
3 [*] 2 = 5
3 [+] 2 = 6

consider a equation :-
x [op] y = res  

x and y are operands 
op : operator
res : result 

types of operators 
1. unary operator (either x or either y)
	when used it modifies the property of the operand 
	eg: x=5  x is +ve x > 0 
		x=-5
		-x it is -ve x > 0
		
	1. - Arthematic Negation
	2. ~ bitwise not 
	3. modify operator 
	    ++ or -- 
		Note : unfortunatly python does not support ++/--
	4. not (logical not)
    5. (cast) operator 
       eg:- 
	   ch = 'A'
	   asci = (int)ch 97
	6. new ---> constructor object create 
	7. delete ---> destructor object delete 
	
	   
2. Binary Operator (taking a and y both)
    2 Operands will be required 
3. ternary operators (x,y and z)
	3 Operand will be required.

Types of Operators in Python:-
===============================
Trick : Are re con log special bit assign karengey
Arthematic Operator : (B)
	used for Mathematical Operations  
	1. native operator
	2. using math module.
Relational Operator(B)
	1. equality  (==) 5==5 True
	2. in-equality (!=) 5!=6 True 
			1. strict in-equality
				1. greater than 
					7 > 3 True.
				2. less than 
					3 < 4 True 
			2. slack in-equality
				1. greater than or equal to 
					x >=5
		           Range = {Inf,6) U (5)
				   x > 5 or x == 5 <------------- logical Or (||)
				   
				2. less than or equal to 
				   x <=5 
				   Range = x => {-Inf,4) U (5)
				   x < 5 or x  == 5 <------------logical Or 
				   
				   
				 we want to define range :-
				 x > 50 and  x < 90 ----------- Logical and (&&)
				
compound conditions:-(B)
======================
1. mendatory (and)
2. optional  (or)
			
logical Operator (B)
	1. and : when all conditions are mendatory it works on the basis AND Gate. 
		(Love Marriage with All Conditions).
		
		1 and 1 => 1 
		1 and 0 => 0 
		0 and 1  => 0 
		0 and 0  => 0
	
	2. or : when any one condition is mendatory it works on the basis of OR Gate
		(Love Marriage with No condition)
		
	   1 and 1 => 1 
	   0 and 1 => 1
	   1 and 0 => 1
	   0 and 0 => 0 

	
	3. not : it is called inverter.
	  True -> False 
	  False -> True 
	  Yes -> No 
	  No -> Yes 
	  
	  TABLE 
	  ----------
	  A | not A 
	  0   1
	  1   0
	
	
bitwise Operator : (B)
1. Bitwise or (|)
2. Bitwise and (&)
3. Bitwise not (~)
4. left shift (<<)
5. right shift (>>)
6. Exclusive Or (^)

1. Note this is not important for as programming level 
2. Not Required in Enterprise Application 
3. DSA -> Bit Manupulation -> Bitwise Operator are mendatory.
4. IOT or Embedded people need.

swapping using Exclusive Or (^):- (B)
====================================
trick : Aba Salam
a = a^b
b = a^b
a = a^b 

Exclusive Or on Basis of Odd Parity and Even Parity:-
====================================================
odd => visam (different)
even => sam (same)

Even Parity => 0 
Odd Parity = 1

0 0 (E) => 0
0 1 (O) => 1
1 0 (O) => 1 
1 1 (E) => 0

1st step a = a^b 
--------------------
a = 2 -> 0010  
b = 3 -> 0011

0010
0011 
--------
0001 => a 
2nd step  b = a^b
======================
0001 -> a 
0011 -> b
-------
0010 -> b -> 2

3rd step a = a^b  
0001 -> a 
0010 -> b 
---------
0011 -> a -> 3 
Assignment Operator (B)
====================
let x=2
x=x+5 => 2+5 => Assign x 


Associativity and Precendence Order :-
2+2 -> Associativity Order L to R 
= -> -> Associativity Order R to L 


x =  x+5 => x+=5
x =  x-5 => x-=5
x =  x*5 => x*=5
x =  x/5 => x/=5
x =  x%5 => x%=5
x =  x//5 => x//=5
x =  x**5 => x**=5

conditional Operator :- (T)
=======================
1. officially python does not Ternary Operator as Other langauge
2. we can implement Ternary using inline if-else 
3. Short hand of if-else

syntax :-
result = True if x else False 


special Operator :-
==================
1. walrus operator (3.10+ Version)
2. match operator  (3.10+ Version)
3. membership operator 
4. instanceof Operator : Already discussed
5. Iterable Operator  : Already discussed
6. identity operator 
7. Match all (3.10+ Version)
8. Match Any (3.10+ Version)
		
match operator :-
=================
match operator was included in python 3.10+ version as a replacement of switch case.
python officially does not support switch statement.
alternative of it, match case 

syntax :--
==========
switch(<value>){
	case <case-1>:{
		statement 1;
		statement 2;
		...
		statement n;
		break;
	}
	case <case-2>:{
		statement 1;
		statement 2;
		...
		statement n;
		break;
	}
	default:{
			statement -1; 
			statement -2;
			...
			statement n;
	}
	break;
}

match(<value>):
   case 1: 
		statement 
   case 2:
		statement 
   case _:
	 statement 


membership operator:-
=======================
in : check if item is available in list 
not in : checks if item is not available in list

it will work collection like string,tuple,list,dictionaries(keys,values)

identity operator :-
=======================
1. is : if a perticular values is a exact copy a member.
	python : 1 shallow copy and deep copy 
	shallow : value copy 
	deep copy : value copy and memory address copy.
2. is not 



working with all()
====================

all() Evaluates True, if all the cases matches to true. 
it works like and condition in the collection.
Eg:-
all([True,True,False]);  False 
all([False,False,False]); 

working with any() it evaluates to true condition even if one condition if one condition.
==================

working Example:-
===================
>>> all([True,True,False])
False
>>> all([True,True,True])
True
>>> all([False,True,True])
False
>>> all([False,False,False])
False
>>> all(['Awnish',29,'cricket',True,None])
False
>>> all(['Awnish',29,'cricket',True])
True
>>> any(['Awnish',29,'cricket',True])
True
>>> any(['Awnish',29,'cricket',True,None])
True
>>> any([None,None])
False
>>>

use case of any and all():-
===========================
any() and all() can be determine weather a collection is homogenious or heterogenious

collection types 
1. homogenious : every member must have same datatype
2. Heterogenous : every memeber have different datatype.

command line argument are special collections with datatype as string.

Basic of Python :-
=================

Q1: What is flavour of Python ?
Ans : cpython

Q2 :- Compilation Order of Python 
	1. Source code ----------> compile ------------> bytecode(.pyc) -----> PVM(Interprter)-->
	execute.

	.pyc -----------> byte code ------> Plateform Independent
	python flexible Langauge, and pvm it hides the bytecodes and directly runs.
	but you want to explicitly generate compiled file you can generate it.
	
Q3 : is python compiled or Interpreted 
Ans: python compiled.
      
	 in python by-default every file,module is not compiled. but it is used a module.
	 then pvm will first compile to byte code and generate __pycache__ folder 
	 and its compiled will be stored in pychache folder.
	 file generated format 
	 
	 filename.<flavour-name>-version.pyc |  compiled python file.
	 

types of input :-
1. compile input :- the arguments or input provide before the execution of the program 
or at compile time also called as command line arguments.
2. Runtime input:- the argument or inputs provided at run time
	 
How to work with compile time arguments:-
========================================
1. argv : argument variable 
2. argc : argument count => len(argv)

important about command line argument:-
in order to work with commmand line argument we need sys module.

import sys 
sys.argv  # list of command line argument


Note : This class has to nothing to offline class.
completly independent.

Important Points about the command line Arguments:-
=====================================================
1. These are arguments that at supplied compile time
2. These are ssv (space seperated values rather than csv and tsv)
3. type of the command line argument is list type
4. first member is file name and is a singleton list.
5. This list are of Homogenuous type 
6. Each memeber weather it is int,float,character, every thing will be string.
7. if you want to space seperated string you must supply it in ""
8. Arguments counts are (n-1) because 0th Index - Filename (p5.py)
9. in order to use argc and argv we need sys module to be imported.


List comprehension:-
====================
it is shortcut way create a new list or dynamic list from the existing or collection.

l = [1,2,3,4,5,5,6,7,8,9,10]
range(1,11) #0 to 10

syntax of list comprehension:-
================================
l = [i for i in list(range(1,11)) if i%2==1 ]


>>> l = [i for i in list(range(1,11)) if i%2==1 ]
>>> l
[1, 3, 5, 7, 9]
>>> d = {'name':'ravi','class':'btech','age':25}
>>> d.keys()
dict_keys(['name', 'class', 'age'])
>>> d.values()
dict_values(['ravi', 'btech', 25])
>>> k =  [key.upper() for key in d.keys()]
>>> k
['NAME', 'CLASS', 'AGE']
>>>

l = [<element to be pushed> for item in <collection> <if condition>]

NLP Use case :-
1. Paragraph  (Corpus) 
2. Sentences  (documents)
3. words  (word tokenise)
4. unique words  (vocablary)
5. grammer (grammer)

dictionary comprehension:-
=========================
it is shortcut way create a new dictionary or dictionary list from the existing or collection
l = [1,2,3,4]

Make a dictionary such that each values is square it own.
{1:1,2:4,3:9,4:16}

working with functions :-
==========================
1. functions are block of code that performs some specific task.
syntax of functions :-

def function_name(param1,param2,param3.....paramn):
	''' doc string '''
	statement 1 
	statement 2
	...
	statement n 
	<return|optional>
	

def add(x,y):
	print('result:',x+y)
	
types of arguments:-
=================
1. positional arguments :  we pass the argument during the calling of the functions with 
						   positional order.
						  position matter a lot.
						  
						  eg: add(10,20) # a=>10 and b=>20
							  add(20,10) # b=>10 and a=20
						 
2. keyword arguments :  here we use, variable name or keyword name, for passing the arguments.
						position does not matter here
						
						eg: add(a=10,b=20) # a=>10 and b=>20
							add(b=20,a=10) # b=>10 and a=20

Types :-                    default argument : it will work when no values passed.
							default argument is assigned with some value
							1. if values is supplied then new value with overwrite the older value.
							2. if values is not supplied then it will use same value for argument.
							3. default argument must be last argument to be declared.
							
							case 1: if default argument passed as positional,so
									default argument must be at last position
							case 2: if default argument is passed as keyword argument
									does order does not matter

Dynamic argument passing:-
========================
	1. if we want to pass dynamic argument, we can use varg-method or variable 
	length argument.
	2. the concept implemented here is tuple-upacking
	3. we can make argument dynamic we prefix *arg 
	
	syntax:
	def fun(*arg):
	
	we can 0,argument, 1 argument or n of argument.
	
	types of combinations:-
	1. *args with positional:-
		=====================
		positional argument it is resolved,
		then *args.
		
		declaration 
		=============
		def fun(a,b,c,*args)
		
		calling:-
		=========
		fun(10,20,30,40,50,60)
		where a = 10
		b = 20 
		c = 30 
		args = (40,50,60)
		
		in this keyword argument passing will not work.
		
   2. *args with keyword:-
   =========================
	*args is resolved and then keyword argument is supplied.
	
	    declaration 
		=============
		def fun(*args,a,b,c)
		
		calling:-
		=========
		fun(10,20,30,a=40,b=50,c=60)
		where 
		a = 40
	b = 50 
	c = 60 
	args = (10,20,30)
	
	
	default argument with *args:-
	================================
	consider a declations:-
	=================================	
	def fun(*args,a=30)
	
	fun(a=50)
	func(10)
	func(10,20)

Note : there can be only one *arg

types of functions on the input and output:-
=============================================
1. input : parameters in the function 
2. output : return types in python we donot have return types (proto-type) hence we dynamically 
   -return any type of value by using return keyword.
By Boolean Algebra:-
Relations if there I =  0 ---------> O = 1
Eg: Program with No input value but may return output.

O(x) = 2^I(x)
Eg:-
O(x) = 2^0 => 1
2 Input => 2^2 => 4

I1 I2 = Output
0   0 
0   1
1   0 
1   1

I(x) O(x)
0     0
0     1
1     0 
1     1

============
trick:-
0  0
1  0
0   1
1   1
functions Types :-
1. No argument No Return Type 
2. No Argument with Return Type 
3. with Argument No Return Type 
4. with Argument with Return Type 

In Python we have total 16 Types of extension in I/O :-
======================================================
1st Type : Positional Argument
1. No Positional-argument No Return Type 
2. No Positional-Argument with Return Type 
3. with Positional-Argument No Return Type 
4. with Positional-Argument with Return Type 

2nd Type : Keyword Argument
1. No Keyword-argument No Return Type 
2. No Keyword-Argument with Return Type 
3. with Keyword-Argument No Return Type 
4. with Keyword-Argument with Return Type 

3rd Type : default Argument
1. No default-argument No Return Type 
2. No default-Argument with Return Type 
3. with default-Argument No Return Type 
4. with default-Argument with Return Type 

4rth Type : *varg Argument
1. No *varg-argument No Return Type 
2. No *varg-Argument with Return Type 
3. with *varg-Argument No Return Type 
4. with *varg-Argument with Return Type 

5th Type : **kwargs Argument
1. No **kwargs Argument No Return Type 
2. No **kwargs Argument with Return Type 
3. with **kwargs Argument No Return Type 
4. with **kwargs Argument with Return Type 

No argument No Return Type (positional):-
============================================
1. declaration:-
	def welcome():
		print('Good Morning')
	
2. calling :-
	welcome()

No argument with Return Type (positional):-
============================================
1. declaration:-
	def gravity():
		return 9.8
	
2. calling :-
	g=gravity()
	print(g)
	
with argument no Return Type (positional):-
============================================
1. declaration:-
	def add(x,y):
		print(x+y)
	
2. calling :-
	add(10,20)
	
with argument with Return Type (positional):-
============================================
1. declaration:-
	def add(x,y):
		return x+y
	
2. calling :-
	result = add(10,20)
	print(result)
	
Returning from the functions:-
=============================
generally in any programming langauge, we can return only 1 value at time.
but if we return multiple values we can return as a collection

1. return as dictionary
2. return as list 
3. return as unique list list(set())
4. return as tuple 
4. returning multiple values. (() are removed)

In All case :-
Argument is May/May Not mendatory but return is mendatory
1. No Argument with No return type : Not valid 
2. with Argument with No Return type : Not valid.

working with global and local scope scope:-
===========================================
inside function : local 
output function : global scope 
non local scope : having local read access but not write global access.

 in order to modify, the global value 
 we need to declare global keyword 
 
 global a;
 a=10
 
working with Recursion:-
==========================
Recursion Types:
1. shallow Recursion
2. Depth Recursion


in c langauge during functions we have 2 types of calls 
1. call by value  : shallow copy
2. call by reference : deep copy

shallow copy : values 
deep copy : memory 

we know that, function calling to itself is called recursion.

1. Sequential calling :-
   Eg:- a function should return to its scope where it is called.
   consider a multiple function calling one another in this scenerio 
   f1() call f2() f3 call f4() call f5()
2. cyclic cycling:
	
important observation about the recursion:-
=============================================
1. is the condition is same or not 
	return n*step3(n-1)
2. if there n step 
	steps 1,2,3,4,5,6............nth 
	
	What is pattern been followed:-
	for steps(n) (n-1)th steps = same condition 
	only one step will have different condition.
	
3. the only step where the condition different is the actual 
	place where your process.
	or we can say we can the result.
	
	 
How to check the recursion limit in Python:-
===========================================
import sys
print(sys.getrecursionlimit())
		 
what is maximum depth of recursion:-
depth = 1000

How to set the limit of the recursion limit:-
============================================
print(sys.setrecursionlimit(2000))
it will print 5 times 
1995 more lines printed.
	 
Recursion was build before loops in order to perform cyclic event, when loop was not invented.

How we can write loops in cyclic calling:-
=========================================
1. Run the infinite 
2. use a counter to count the no of cycles.
3. add termination condition.

in cycling calling we have 2 main conditions 
1. race condition : No condition is check hence it is handled by else.
2. base condition : for base condition we have if.
	

modules and packages:-
======================
python supports modular programming.
you can modularize your code into different different modules and packages.

what is python file:-
a python file is a collection for variables, syntaxes, logic, functions and classes.

in python every python file is a module.
if it is a module we can utilise it and import in other file.

module : using the source code in other file is said to be module.

Types of modules:-
=================
1. pre-defined modules :  modules which comes ready made with python is said to be pre-defined.
2. user-defined module : modules which are made by user for there own purpose.

modules are of two types 
1. internal modules :  we need not to install them.
2. external modules :  they are not available in the system has to be externally installed 
	using pip 
	Eg:- 
	-pip install django 
	-pip uninstall django
	
consider django is ready made or user-defined.
but django it does not come pre-defined
we need to install it.

Who invented python ?
Guido Van Rossum.
	print() -> prefined 
	input() -> prefined
	math module: pre-defined
	
Note : every ready-made module or functions is once user-defined.
Aviskar : xyz module : user-defined
Anand : import xyz  : pre-defined

1. sys 
2. os 
3. keyword 
4. math 
5. random 
6. collection 

there are some modules which comes pre-installed as you install python.
Are these required to be externally installed. : No install 
Internal modules.
if i am  building some module for own purpose will it will be available in my system or not.

How to make our own module:-
===============================
p1.py 

a=10 
def wish():
	print('wish functions')
	
def add(x,y):
	return x+y 
	
	
class Test:
	def display():
		print('The time is : 09:00 PM')


p2.py 

import p1 #module

p1.a 
p1.wish()
p1.add(10,20)

t = p1.Test()
t.display()

module aliasing :- 
======================
giving a pet name to a module name or giving a secondary name to modulename 
syntax 

import module as new_name

new_name.x 
new_name.y 
new_name.abc()

Note : alias name should be less than lenght of module_name.

specific member import :-
=====================
what are members :- All the variable,methods or classes defined or any Indentifier.
inside a module is said to be member.
from .. import statement.

syntax :-
=========
single member:- 
from module import member
or 

multiple members 
from module import member1,member2,member3

Note:-
Only those memeber which are import will available.

packages is a collections of modules.
consider module p1.py p2.py p3.py pn.py ------------> place them in a folder.
Now this special folder will be called as package

multiple modules kept in a folder is said to be packages.
what is advantage of package:-
==============================
mmt : make my trip.
mmt main usp trip planning.

Honeymoon package.
7 days 7 night 

1. tickets 2 awnish sunny
2. flight ticket elipi and munnar
3. Hotels 
4. tourist guide
5. cabs and boats 
6. camera

50-60 Thousand.
1. time constraint 
2. budgets. 
3. management and cross dependency.

packages is a collection different modules and services kept in a single folder with mechanism
to manage modules,setup,use,and publish modules.
 
folder structure of the packages 
1. your-package
	  |m1.py 
	  |m2.py 
	  |m3.py 
	  |__init__.py
there should be one special file 
 
__init__.py : this file is important it could be blank
__init__.py : it is entry point of the packages.
__init__.py : is a special file which will automatically as soon packages is imported.


sub-packages :- 	
	packages inside packages 
	
package 
	|sub-package 
		|__init__.py  --------> init module 
		|m1.py
	|__init__.py 
	|a.py 
	
from package.sub-package import m1
from package import a

NLP :-
======
gensim package 
from genism.load import api 

How to publish our packages as setup file :-
=============================================
like when you download any software we get .exe -> install 
How to share our package we have two ways 
1. zip -> share 
2. make a wheel file.

what is wheel file :-
====================
wheel file is a special file, just .exe which has inbuilt setuptool which will automatically install your package in system.
my_package ---> convert to -----> wheel(.whl)
it is like a build file of the package.

Advantage :- 
1. Fast installation
2. globally install.
3. easy to publish and share.

How to make wheel files :-
===========================
1. pip install setuptools
2. pip install wheel 

python -m pip install wheel
Requirement already satisfied: wheel in c:\users\imart\anaconda3\lib\site-packages (0.44.0)

python -m pip install setuptools
Requirement already satisfied: setuptools in c:\users\imart\anaconda3\lib\site-packages (80.9.0)

we want to make my_package.whl (wheel for the my_package)
create a file name setup.py

my_package
|
setup.py 
readme.txt optional 
readme.md optional

we make build:-
================
python setup.py sdist bdist_wheel

where sdist : system distribution 
bdist_wheel : binary distribution of wheel

How to install wheel file :-
pip install <filename.whl>

decorators:-
=============
decorator is a like functions a higher order functions.
what is higher order functions 
A function is said to be higher order functions if it takes function as a argument and returns
functions is said to be HOF

What is difference b/w:-

def f():
	print('f is executing..')

d = f 
print(d) 
d = f()
print(d)

nested functions :-
===================
functions declared inside another function.

def a():
	print('a body started')
	def b():
		print('b body started')
		print('b body ended')
	print('a body ended')



a()

function as Argument and return as functions:-
===============================================
Here we will pass function defnition as argument and return function as output 

What is decorator:-
==================
1. is a HOF 
2. decorator is a HOOK.
	
	Hook : it can grab machhli hook, without going inside water, we can catch the machhli 
	and cook and eat.
	
3. A decorator is a like special which is used to add addtional functionality to existing 
	class or method or functions without changing there syntax.

4. decorator can run before and after the function 
	pre decorator : called before functions call.
	post decorator : called after functions call.
	
	
calling the decorator:-
@decorator : Annotation 

consider a buy a gift it is already packed, you asked the gift decorator please wrap this 
into gift wrapper Now this more decorated gift.

decorator is a wrapper of the functions.
syntax :-

def my_decorator(func):
	def wrapper():
		res = func()
		return res
	return wrapper
	
	
working with pandas:-
1.pandas are very famous library used for data handling, data manipulation and 
data Abnalytics and cleaning.

main purpose of pandas 
1. Data Storage and Reprensentation
	1. store data in series 1d and 2d (Dataframe) like Excel
	2. like numpy the data type of np.array should be homogenious
	but in case of pandas we can use any type of value of the fields.
	
	3. we can store heterogenious data elements also.

2. Data Cleaning 
	1. Remove Duplicate 
	2. handle missingvalue (dropna or fillna)
	3. Replace,reformat,normalise the data.
	
3.  Data Transformation:-
1. filter,sort,group,merge,pivot,reshape the dataset. (v lookup)

4. Data Analytics : generate the automatic report.
	1. find the meta data like (mean,sum,count)
	
5. time Series Analysis
6. Data or Input and output layer
	1. read/write from csv,excel,sql,...etc 
7. smooth Integration  using numpy,matplotlib,seaborn,sckit learns

Working with nltk :-
====================
Concepts 
1. tokenisation 
2. stop word removal 
3. stemming & Lemmatization 
4. Name Entity Recognistion 
5. Chunking 
6. POS Tagging
7. Context Free Grammer 
8. Parse Tree 
9. Probability Distribution with Graphical Plotting 

Native langauge use : English.
NLP Use case : Human Understand Information 













	





























	
	
	
	
	

































	
	













































































































	
	
	




	  
	  
	  
	  
 







































































































	
	
	

	
	
	
	
	
	





	
		 
		     
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	 
	 
	
	
	
	
	
	
	
	
	
	
	
	

		
		
		
	















	 














































	
	
	
	














 












	   
	   
	   
	   




